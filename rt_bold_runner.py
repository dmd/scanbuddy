#!/usr/bin/env python3

import os
import sys
import glob
import json
import time
import pydicom
import logging
import argparse
import subprocess
import numpy as np
from queue import Empty
from pathlib import Path
from pprint import pprint
from multiprocessing import Process, Queue
from watchdog.events import LoggingEventHandler
from watchdog.observers.polling import PollingObserver

logger = logging.getLogger(__name__)

logger.setLevel(logging.DEBUG)

# Parse command-line arguments
parser = argparse.ArgumentParser(description='Watch a directory for DICOM files.')
parser.add_argument('--watch-dir', type=str, required=True,
                    help='The directory to watch for DICOM files.')
args = parser.parse_args()

directory_to_watch = args.watch_dir

def watch_directory(q):
    dicom_list = []

    class MyHandler(LoggingEventHandler):
        def on_created(self, event):
            if event.src_path.endswith('.dcm'):
                dicom_list.append(event.src_path)
                q.put(event.src_path)  # Put the new file into the queue

    event_handler = MyHandler()
    observer = PollingObserver()
    observer.schedule(event_handler, directory_to_watch, recursive=True)
    observer.start()

    try:
        while True:
            time.sleep(.1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()


#def run(dicom_list):
def run(dcm1, dcm2):


    nii_1 = run_dcm2niix(dcm1, 1)
    nii_2 = run_dcm2niix(dcm2, 2)

    # run volreg command

    sub_arr = run_volreg(nii_1, nii_2)

    #print(f'matrix generated by 3dvolreg: {sub_arr}')
    
    clean_dir(nii_1, nii_2, directory_to_watch)

    return sub_arr
    
def dcm_sort(dicom_list):
    instance_numbers = []
    for f in dicom_list:
        ds = pydicom.dcmread(f, force=True)
        instance_numbers.append(int(ds.InstanceNumber))

    sorted_files = [x for _,x in sorted(zip(instance_numbers, dicom_list))]

    return sorted_files

def clean_dir(nii_1, nii_2, directory_to_watch):
    os.remove(nii_1)
    os.remove(nii_2)
    os.remove(f'{directory_to_watch}/maxdisp_delt')
    os.remove(f'{directory_to_watch}/maxdisp')
    os.remove(f'{directory_to_watch}/moco.par')
    for file in glob.glob('*.json'):
        os.remove(file) 

def run_dcm2niix(dicom, num):
    dcm2niix_cmd = [
       'dcm2niix',
       '-b', 'y',
       '-z', 'y',
       '-s', 'y',
       '-f', f'bold_{num}',
       '-o', directory_to_watch,
       dicom
    ]

    output = subprocess.check_output(dcm2niix_cmd, stderr=subprocess.STDOUT)

    nii_file = find_nii(directory_to_watch, num)

    return nii_file

def run_volreg(nii_1, nii_2):
    mocopar = os.path.join(directory_to_watch, f'moco.par')
    maxdisp = os.path.join(directory_to_watch, f'maxdisp')
    cmd = [
        '3dvolreg',
        '-base', nii_1,
        '-linear',
        '-1Dfile', mocopar,
        '-maxdisp1D', maxdisp,
        '-x_thresh', '10',
        '-rot_thresh', '10',
        '-prefix', 'NULL',
        nii_2
    ]

    _ = subprocess.check_output(cmd, stderr=subprocess.STDOUT)

    arr = np.loadtxt(mocopar)

    return arr


def find_nii(directory, num):
    for file in os.listdir(directory):
        if f'bold_{num}' in file and file.endswith('.gz'):
            return os.path.join(directory, file)

def verify_sequential(dcm1, dcm2):
    dcm1_num = int(pydicom.dcmread(dcm1, force=True).InstanceNumber)
    dcm2_num = int(pydicom.dcmread(dcm2, force=True).InstanceNumber)
    print(dcm1_num)
    print(dcm2_num)

    return dcm2_num == dcm1_num + 1

if __name__ == '__main__':
    
    q = Queue()
    p = Process(target=watch_directory, args=(q,))
    p.start()
    
    dicom_list = []  # Initialize an empty list outside the while loop

    large_array = []

    while True:
        try:
            new_file = q.get(timeout=1)  # Get the new file from the queue
            dicom_list.append(new_file)  # Append the new file to the list
            dicom_list = dcm_sort(dicom_list)
            if len(dicom_list) < 2:
                continue
            dcm1 = dicom_list[0]
            dcm2 = dicom_list[1]
            if not verify_sequential(dcm1, dcm2):
                #time.sleep(1)
                new_file = q.get()
                dicom_list.append(new_file)
                dicom_list = dcm_sort(dicom_list)
                dcm1 = dicom_list[0]
                dcm2 = dicom_list[1]
                logger.warning(f'dcm1 re-read: {dcm1}')
                print(f'dcm2 re-read: {dcm2}')
                if not verify_sequential(dcm1, dcm2):
                    logger.warning(f'Missing dicom data volume: {int(pydicom.dcmread(dcm1, force=True).InstanceNumber) + 1}')
                dicom_list.pop(0)
            else:
                dicom_list.pop(0)
            print(dcm1)
            print(dcm2)

            sub_arr = run(dcm1, dcm2)
            #large_array = np.append(large_array, sub_arr)
            large_array.append(sub_arr)
            print(large_array)
        except Empty:
            continue